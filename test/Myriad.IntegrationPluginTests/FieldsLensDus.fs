//------------------------------------------------------------------------------
//        This code was generated by myriad.
//        Changes to this file will be lost when the code is regenerated.
//------------------------------------------------------------------------------
module Test1Lenses =
    open Input

    let inline one =
        (fun (x: Test1) -> x.one), (fun (x: Test1) (value: int) -> { x with one = value })

    let inline two =
        (fun (x: Test1) -> x.two), (fun (x: Test1) (value: string) -> { x with two = value })

    let inline three =
        (fun (x: Test1) -> x.three), (fun (x: Test1) (value: float) -> { x with three = value })

    let inline four =
        (fun (x: Test1) -> x.four), (fun (x: Test1) (value: float32) -> { x with four = value })
module RecordWithWrappedLensLenses =
    open Input

    let inline one =
        Example.Lens(
            (fun (x: RecordWithWrappedLens) -> x.one),
            (fun (x: RecordWithWrappedLens) (value: int) -> { x with one = value })
        )
module RecordWithEmptyWrapperNameLenses =
    open Input

    let inline one_empty_wrapper_name =
        (fun (x: RecordWithEmptyWrapperName) -> x.one_empty_wrapper_name),
        (fun (x: RecordWithEmptyWrapperName) (value: int) ->
            { x with
                one_empty_wrapper_name = value })
module RecordWithWrappedLensViaTypedefofLenses =
    open Input

    let inline one_typedefof =
        Example.Lens(
            (fun (x: RecordWithWrappedLensViaTypedefof) -> x.one_typedefof),
            (fun (x: RecordWithWrappedLensViaTypedefof) (value: Option<int>) -> { x with one_typedefof = value })
        )
module RecordWithWrappedLensViaTypeofLenses =
    open Input

    let inline one_typeof =
        Example.Lens(
            (fun (x: RecordWithWrappedLensViaTypeof) -> x.one_typeof),
            (fun (x: RecordWithWrappedLensViaTypeof) (value: Option<int>) -> { x with one_typeof = value })
        )
module AddressLenses =
    open Input

    let inline Street =
        Example.Lens((fun (x: Address) -> x.Street), (fun (x: Address) (value: string) -> { x with Street = value }))

    let inline HouseNumber =
        Example.Lens(
            (fun (x: Address) -> x.HouseNumber),
            (fun (x: Address) (value: int) -> { x with HouseNumber = value })
        )
module PersonLenses =
    open Input

    let inline Name =
        Example.Lens((fun (x: Person) -> x.Name), (fun (x: Person) (value: string) -> { x with Name = value }))

    let inline Address =
        Example.Lens((fun (x: Person) -> x.Address), (fun (x: Person) (value: Address) -> { x with Address = value }))
module AetherAddressLenses =
    open Input

    let inline Street =
        (fun (x: AetherAddress) -> x.Street), (fun (value: string) (x: AetherAddress) -> { x with Street = value })

    let inline HouseNumber =
        (fun (x: AetherAddress) -> x.HouseNumber),
        (fun (value: int) (x: AetherAddress) -> { x with HouseNumber = value })
module AetherPersonLenses =
    open Input

    let inline Name =
        (fun (x: AetherPerson) -> x.Name), (fun (value: string) (x: AetherPerson) -> { x with Name = value })

    let inline Address =
        (fun (x: AetherPerson) -> x.Address),
        (fun (value: AetherAddress) (x: AetherPerson) -> { x with Address = value })
module SingleCaseDULenses =
    open Input

    let inline Lens' =
        let inline getter (x: SingleCaseDU) =
            match x with
            | Single x -> x

        getter, (fun (_: SingleCaseDU) (value: int) -> Single value)
module WrappedSingleCaseDULenses =
    open Input

    let inline Lens' =
        Example.Lens(
            let inline getter (x: WrappedSingleCaseDU) =
                match x with
                | SingleWrapped x -> x

            getter, (fun (_: WrappedSingleCaseDU) (value: int) -> SingleWrapped value)
        )
module FullyQualifiedDULenses =
    open Input

    let inline Lens' =
        let inline getter (x: FullyQualifiedDU) =
            match x with
            | FullyQualifiedDU.FullyQualified x -> x

        getter, (fun (_: FullyQualifiedDU) (value: string) -> FullyQualifiedDU.FullyQualified value)
module Module_SingleCaseDULenses =
    open Input.ModuleWithDUs

    let inline Lens' =
        let inline getter (x: Module_SingleCaseDU) =
            match x with
            | Single x -> x

        getter, (fun (_: Module_SingleCaseDU) (value: int) -> Single value)
module Module_WrappedSingleCaseDULenses =
    open Input.ModuleWithDUs

    let inline Lens' =
        Example.Lens(
            let inline getter (x: Module_WrappedSingleCaseDU) =
                match x with
                | SingleWrapped x -> x

            getter, (fun (_: Module_WrappedSingleCaseDU) (value: int) -> SingleWrapped value)
        )
module Module_FullyQualifiedDULenses =
    open Input.ModuleWithDUs

    let inline Lens' =
        let inline getter (x: Module_FullyQualifiedDU) =
            match x with
            | Module_FullyQualifiedDU.FullyQualifiedCase x -> x

        getter, (fun (_: Module_FullyQualifiedDU) (value: int) -> Module_FullyQualifiedDU.FullyQualifiedCase value)

module Test1 =
    open Input
    let inline one (x: Test1) = x.one
    let inline two (x: Test1) = x.two
    let inline three (x: Test1) = x.three
    let inline four (x: Test1) = x.four
    let inline create (one: int) (two: string) (three: float) (four: float32) : Test1 = { }

    let inline map
        (mapone: int -> int)
        (maptwo: string -> string)
        (mapthree: float -> float)
        (mapfour: float32 -> float32)
        (record': Test1)
        : Test1 =
        { record' with }

module Currency =
    open Input

    let inline toString (x: Currency) : string =
        match x with
        | CAD -> "CAD"
        | PLN -> "PLN"
        | EUR -> "EUR"
        | USD -> "USD"
        | Custom _ -> "Custom"

    let inline fromString (x: string) : Option<Currency> =
        match x with
        | "CAD" -> Some CAD
        | "PLN" -> Some PLN
        | "EUR" -> Some EUR
        | "USD" -> Some USD
        | _ -> None

    let inline toTag (x: Currency) : int =
        match x with
        | CAD -> 0
        | PLN -> 1
        | EUR -> 2
        | USD -> 3
        | Custom _ -> 4

    let inline isCAD (x: Currency) : bool =
        match x with
        | CAD -> true
        | _ -> false

    let inline isPLN (x: Currency) : bool =
        match x with
        | PLN -> true
        | _ -> false

    let inline isEUR (x: Currency) : bool =
        match x with
        | EUR -> true
        | _ -> false

    let inline isUSD (x: Currency) : bool =
        match x with
        | USD -> true
        | _ -> false

    let inline isCustom (x: Currency) : bool =
        match x with
        | Custom _ -> true
        | _ -> false


